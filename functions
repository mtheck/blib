#!/usr/bin/env bash

[[ $__functions__ ]] && return

_error_ () { echo 0; }
_warn_  () { echo 1; }
_note_  () { echo 2; }
_msg_   () { echo 3; }
_debug_ () { echo 4; }
_trace_ () { echo 5; }

_error () { log -0; }
_warn  () { log -1; }
_note  () { log -2; }
_msg   () { log -3; }
_debug () { log -4; }
_trace () { log -5; }

error () { log 0 "$@"; exit 1; }
warn  () { log 1 "$@"; }
note  () { log 2 "$@"; }
msg   () { log 3 "$@"; }
debug () { log 4 "$@"; }
trace () { log 5 "$@"; }

function errorf {
	[[ $# -gt 0 ]] || set "Invalid arguments"

	( error "${BASH_SOURCE[2]}[${BASH_LINENO[1]}] ${FUNCNAME[1]}:" "$@" ) || :

	echo 2
}

function is_declared {
	[[ $# -ge 1 ]] || return $(errorf)

    local attrs=$(declare -p "$1" 2>/dev/null | awk -v RS= '{print $2}')
    shift

    [[ $attrs ]] || return 1
    [[ $# -gt 0 ]] || return 0

    attrs=${attrs##*-}

    local i t_attrs
    for t_attrs in "$@"; do
	    for ((i=0; i<${#t_attrs}; i++)); do
	    	[[ $attrs != *${t_attrs:i:1}* ]] && continue 2
		done
		return 0
	done
    return 3
}

function is_string {
	[[ $# -eq 1 ]] || return $(errorf)

	if is_declared "$1" i a A; then
		return 1
	elif [[ $? -eq 3 ]]; then
		return 0
	fi
	return 1
}

function is_integer {
	[[ $# -eq 1 ]] || return $(errorf)

	is_declared "$1" i
}

function is_array {
	[[ $# -eq 1 ]] || return $(errorf)

	is_declared "$1" a
}

function is_hash {
	[[ $# -eq 1 ]] || return $(errorf)

	is_declared "$1" A
}

function is_function {
	[[ $# -eq 1 ]] || return $(errorf)

	declare -F "$1" >/dev/null
}

function is_command {
	[[ $# -eq 1 ]] || return $(errorf)

	[[ $(type -P "$1") ]]
}

function is_exec {
	[[ $# -eq 1 ]] || return $(errorf)

	is_command "$1" || is_function "$1" || [[ $(type -t "$1") == builtin ]]
}

function bool {
	[[ $# -eq 1 ]] || return $(errorf)

	case $1 in
    true | TRUE | True | \
    yes | YES | Yes | \
    on | ON | On | \
    1)
	return 0
	;;
    false | FALSE | False | \
    no | NO | No | \
    off | OFF | Off | \
    0)
	return 1
	;;
	esac
	return 3
}


function quote {
	[[ $# -eq 1 ]] || return $(errorf)

    echo "'${1//\'/\'\\\'\'}'"
}

function color {
	[[ $# -eq 1 ]] || return $(errorf)

	colorc "$1" && echo -n "$COLORC"
}

function colorc {
	local - && set +x

	[[ $# -eq 1 ]] || return $(errorf)

	local -A cc=(
		[none]=0
		[black]=30
		[red]=31
		[green]=32
		[yellow]=33
		[blue]=34
		[magenta]=35
		[cyan]=36
		[white]=37
	)
	local -A sc=(
		[+]=1
		[-]=2
		[/]=3
		[=]=4
		[%]=7
	)

	unset COLORC

	local i code list elem name fmt num

	list=$1

	while [[ $list ]]; do
		elem=${list%%,*}
		list=${list:${#elem}}

		name=${elem%%[![:word:]]*}
		fmt=${elem:${#name}}

		if [[ $name ]]; then
			num=${cc[$name]}

			if [[ $num ]]; then
				[[ $list ]] && ((num+=10))
				[[ $code ]] && code+=\;
				code+=$num
			else
				code=
				break
			fi
		fi

		for ((i=0; i<${#fmt}; i++)); do
			num=${sc[${fmt:i:1}]}

			if [[ $num ]]; then
				code+=\;$num
			else
				code=
				break 2
			fi
		done

		list=${list#,}
	done

	[[ $code ]] || return

	COLORC=$'\e'[${code}m
}

function echoc {
	local - && set +x

	local nl
	[[ $1 == -n ]] && nl=$1 && shift

	local color base code sep=${IFS:0:1}

	if [[ $ECHOC ]]; then
		bool $ECHOC && color=_
	else
		[[ -t 1 ]] && color=_
	fi

	if [[ $ECHOC_BASE ]] && colorc "$ECHOC_BASE"; then
		base="$COLORC"
	fi

	local out space spec

	while [[ $# -gt 0 ]]; do
		spec=${1#@}

		if [[ ${1:0:1} == @ ]] && colorc "${spec%@}"; then
			code="$COLORC"
			[[ ${1: -1} == @ ]] && space=_ || space=
		else
			if [[ ! $out ]]; then
				[[ $base && $color ]] && out+=$base
			else
				[[ $space ]] && out+=$sep
			fi

			if [[ $code ]]; then
				[[ $color ]] && out+=$code
			fi

			out+=$1

			if [[ $code ]]; then
				if [[ $color ]]; then
					out+=$'\e'[0m
					[[ $base ]] && out+=$base
				fi
				code=
			fi

			space=_
		fi

		shift
	done

	[[ $base && $color ]] && out+=$'\e'[0m

	echo $nl "$out"
}

function echoe {
	echoc "$@" >&2
}

function log {
	local - && set +x

	[[ $# -ge 1 ]] || return $(errorf)

	local level=$1 && shift

	valid_int "$level" || return $(errorf "Invalid log level")

	local levels=(
		Error:red
		Warning:yellow
		Note:green
		:cyan
		DEBUG:
		TRACE:
	)

	local test drop

	if [[ $level == -* ]] ; then
		test=_
		level=${level##*-}
	fi

	local level_def=${levels[$level]} log_level=${LOG_LEVEL}

	[[ $level_def ]] || return $(errorf "Unknown log level")

	if [[ $log_level == _ ]]; then
		drop=_
	else
		valid_uint "$log_level" || log_level=3

		[[ $log_level -lt $level ]] && drop=_
	fi

    if [[ $test ]]; then
    	[[ $drop ]] && return 1
    	return 0
    fi
    [[ $drop ]] && return 0

	local header=${level_def%%:*} color=${level_def##*:}

	[[ $color ]] || color=none

	local header_color=$color sep_color=$color

	if [[ $color != none ]]; then
		header_color+=+=
		sep_color+=+
	fi

	local log_prefix_opt log_prefix=$LOG_PREFIX

	if [[ $log_prefix == [+-]* ]]; then
		log_prefix_opt=${log_prefix:0:1}
		log_prefix=${log_prefix#?}
	fi
	if [[ $log_prefix == _ ]]; then
		log_prefix=
	elif [[ ! $log_prefix ]]; then
		log_prefix='>>>'
	fi

	local prefix=$log_prefix prefix_args=() header_args=()

	[[ -t 2 && $log_prefix_opt != + ]] && prefix=

	if [[ $header ]]; then
		header_args+=(@$header_color "$header")
		header_args+=(@$sep_color ': ')

		if [[ $header == ${header^^} ]]; then
			[[ $log_prefix_opt != - ]] && prefix=$log_prefix
		fi
	fi

	if [[ $prefix ]]; then
		prefix_args+=("$prefix")
	fi

	if bool "$LOG_DATE" || [[ ! $LOG_DATE && $log_level -ge 4 ]]; then
		if [[ $LOG_DATE_FORMAT ]]; then
			prefix_args+=("[$(date +"$LOG_DATE_FORMAT")]")
		else
			prefix_args+=("[$(date -In)]")
		fi
	fi

	if bool "$LOG_SOURCE" || [[ ! $LOG_SOURCE && $log_level -ge 5 ]]; then
		local -i depth=0
		[[ ${BASH_SOURCE[depth]} == "${BASH_SOURCE[depth+1]}" ]] && depth+=1

		prefix_args+=("{${BASH_SOURCE[depth+1]}:${BASH_LINENO[depth]}}")
	fi

	[[ ${#prefix_args[@]} -gt 0 ]] && prefix_args=("${prefix_args[*]}${IFS:0:1}")

	echoe -n "${prefix_args[@]}" "${header_args[@]}"
	ECHOC_BASE=$color echoe "$@"
}

function ask {
	local question=$1 && shift || :

	[[ $question ]] || question=?

	local -A answers
	local answer choose reply

	for answer in "$@"; do
		answers[$answer]=_
	done

	[[ $# -gt 0 ]] && choose=" ($(IFS=\|; echo "$*"))"

    while :; do
        echoe -n @yellow+ "$question$choose: "
        read reply

    	[[ $# -gt 0 ]] || break
        [[ ${answers[$reply]} ]] && break
    done

    echo "$reply"
}

function confirm {
	[[ $# -eq 0 ]] || return $(errorf)

	[[ $(ask "Are you sure you want to continue?" y n) == y ]]
}

function valid_name {
	[[ $# -eq 1 ]] || return $(errorf)

	[[ $1 =~ ^[[:alpha:]_]([[:alnum:]_]*)?$ ]]
}

function valid_identifier {
	[[ $# -eq 1 ]] || return $(errorf)

	[[ $1 =~ ^[[:alpha:]]([[:alnum:]-]*[[:alnum:]])?$ ]]
}

function valid_int {
	[[ $# -eq 1 ]] || return $(errorf)

	[[ $1 =~ ^[-+]?[[:digit:]]+$ ]]
}

function valid_uint {
	[[ $# -eq 1 ]] || return $(errorf)

	valid_int "$1" && [[ ${1:0:1} != - ]]
}

function valid_float {
	[[ $# -eq 1 ]] || return $(errorf)

	[[ $1 =~ ^[-+]?[[:digit:]]*\.?[[:digit:]]+([eE][[:digit:]]+)?$ ]]
}

function valid_ufloat {
	[[ $# -eq 1 ]] || return $(errorf)

	valid_float "$1" && [[ ${1:0:1} != - ]]
}

function valid_bool {
	[[ $# -eq 1 ]] || return $(errorf)

	bool "$1" || [[ $? -ne 3 ]]
}

function parse_duration {
	[[ $# -eq 1 ]] || return $(errorf)

	local duration=$1

    local -A units=(
        [s]=1
        [m]=60
        [h]=3600
    )

    local -i seconds=0

    local num unit factor

    while [[ $duration ]]; do
    	num=${duration%%[!0-9]*}

    	[[ $num ]] || return 1

    	duration=${duration:${#num}}
    	unit=${duration%%[0-9]*}

    	[[ $unit ]] || unit=s

    	duration=${duration:${#unit}}
		factor=${units[$unit]}

    	[[ $factor ]] || return 1

    	((seconds+=num*factor))
    done

    echo $seconds
}

function trim {
	[[ $# -ge 1 && $# -le 2 ]] || return $(errorf)

    _trim _ "$@"
}

function triml {
	[[ $# -ge 1 && $# -le 2 ]] || return $(errorf)

    _trim - "$@"
}

function trimr {
	[[ $# -ge 1 && $# -le 2 ]] || return $(errorf)

    _trim + "$@"
}

function _trim {
    local side=$1 str=$2 chars=$3

	[[ $# -gt 2 ]] || chars=$IFS

	[[ $chars ]] || echo "$str"

	local i len

	if [[ $side == - || $side == _ ]]; then
		len=${#str}
		for ((i=0; i<len; i++)); do
			[[ $chars == *"${str:i:1}"* ]] || break
		done
		str=${str:i}
	fi

	if [[ $side == + || $side == _ ]]; then
		len=${#str}
		for ((i=len; i>0; i--)); do
			[[ $chars == *"${str:i-1:1}"* ]] || break
		done
		str=${str:0:i}
	fi

    echo "$str"
}

function array_push {
	[[ $# -ge 2 && $# -le 3 ]] || return $(errorf)

	valid_name "$1" || return $(errorf "Illegal variable name")

	[[ $1 == __v_* ]] && return $(errorf "Conflicting variable name")

	local __v_name=$1 __v_list=$2 __v_delim=,

	is_array "$__v_name" || ! is_declared "$__v_name" || return $(errorf "Variable is not an array")

	if [[ $# -gt 2 ]]; then
		__v_delim=$3

		[[ ${#__v_delim} -le 1 ]] || return $(errorf "List delimiter must be a single character")
	fi

	readarray -O "$(eval "echo \${#$__v_name[@]}")" -d "$__v_delim" -t "$__v_name" < <(echo -n "$2")
}

function array_split {
	[[ $# -eq 3 ]] || return $(errorf)

	valid_name "$1" || return $(errorf "Illegal variable name")

	[[ $1 == __v_* ]] && return $(errorf "Conflicting variable name")

	local __v_name=$1 __v_str=$2 __v_regex=$3

	is_array "$__v_name" || ! is_declared "$__v_name" || return $(errorf "Variable is not an array")

	local __v_len __v_res=()

	while :; do
		if [[ $__v_str =~ ($__v_regex).* ]]; then
			[[ ${BASH_REMATCH[1]} ]] || return $(errorf "Empty separator regular expression")

			__v_res+=("${__v_str:0:-${#BASH_REMATCH[0]}}")
			__v_str=${__v_str:${#__v_str}-${#BASH_REMATCH[0]}+${#BASH_REMATCH[1]}}
		else
			[[ $? -eq 1 ]] || return $(errorf "Invalid separator regular expression")

			__v_res+=("$__v_str")
			__v_str=
		fi

		[[ $__v_str ]] || break
	done

    eval "$__v_name=(\"\${__v_res[@]}\")"
}

function array_filter {
	[[ $# -ge 3 ]] || return $(errorf)

	valid_name "$1" || return $(errorf "Illegal variable name")

	[[ $1 == __v_* ]] && return $(errorf "Conflicting variable name")

	local __v_name=$1 __v_op=$2 __v_type=_ __v_filter=$3 && shift 3

	is_array "$__v_name" || return $(errorf "Variable is not an array")

	if [[ ${#__v_op} -gt 1 ]]; then
		__v_type=${__v_op:1}

		[[ $__v_type == [_=~@] ]] || return $(errorf "Invalid filter operator")

		if [[ $__v_type == '@' ]]; then
			is_exec "$__v_filter" || return $(errorf "Filter command not defined")
		else
			[[ $# -eq 0 ]] || return $(errorf)
		fi

		__v_op=${__v_op:0:1}
	fi

	[[ $__v_op == [-+] ]] || return $(errorf "Invalid filter operator")

	local __v_len="$(eval "echo \${#$__v_name[@]}")" __v_res=()

	local __v_idx __v_val __v_match __v_found __v_arg __v_args=()

    for ((__v_idx=0; __v_idx<$__v_len; __v_idx++)); do
		__v_val=$(eval "echo \"\${$__v_name[$__v_idx]}\"")
		__v_match=

		case $__v_type in
		'_')
			if [[ $__v_val == "$__v_filter" ]]; then
				__v_match=_
			fi
			;;
		'=')
			if [[ $__v_val == $__v_filter ]]; then
				__v_match=_
			fi
			;;
		'~')
			if [[ $__v_val =~ $__v_filter ]]; then
				__v_match=_
			else
				[[ $? -eq 1 ]] || return $(errorf "Invalid filter regular expression")
			fi
			;;
		'@')
			__v_args=()
			__v_found=

			for __v_arg in "$@"; do
			    if [[ $__v_arg == *{}* ]]; then
			        __v_arg=${__v_arg//\{\}/"$__v_val"}
			        __v_found=_
			    fi
			    __v_args+=("$__v_arg")
			done
			[[ $__v_found ]] || __v_args+=("$__v_val")

			if $__v_filter "${__v_args[@]}" >/dev/null; then
				__v_match=_
			fi
			;;
		esac

		if [[ $__v_match ]]; then
			[[ $__v_op == - ]] && continue
		else
			[[ $__v_op == + ]] && continue
		fi

        __v_res+=("$__v_val")
    done

    eval "$__v_name=(\"\${__v_res[@]}\")"
}

function array_map {
	[[ $# -ge 2 ]] || return $(errorf)

	valid_name "$1" || return $(errorf "Illegal variable name")

	[[ $1 == __v_* ]] && return $(errorf "Conflicting variable name")

	local __v_name=$1 __v_fct=$2 && shift 2

	is_array "$__v_name" || return $(errorf "Variable is not an array")

	is_exec "$__v_fct" || return $(errorf "Map command not defined")

	local __v_len="$(eval "echo \${#$__v_name[@]}")" __v_res=()

	local __v_idx __v_val __v_found __v_arg __v_args=()

    for ((__v_idx=0; __v_idx<$__v_len; __v_idx++)); do
		__v_val=$(eval "echo \"\${$__v_name[$__v_idx]}\"")

		__v_args=()
		__v_found=

		for __v_arg in "$@"; do
		    if [[ $__v_arg == *{}* ]]; then
		        __v_arg=${__v_arg//\{\}/"$__v_val"}
		        __v_found=_
		    fi
		    __v_args+=("$__v_arg")
		done
		[[ $__v_found ]] || __v_args+=("$__v_val")

		__v_val=$($__v_fct "${__v_args[@]}") || return $?

        __v_res+=("$__v_val")
    done

    eval "$__v_name=(\"\${__v_res[@]}\")"
}

function list_contains {
	[[ $# -ge 1 ]] || return $(errorf)

    local elem=$1 && shift

    local e
    for e in "$@"; do
        [[ $e == "$elem" ]] && return 0
    done
    return 1
}

function list_selects {
	[[ $# -ge 1 ]] || return $(errorf)

	[[ $# -gt 1 ]] || return 0

    list_contains "$@"
}

function list_join {
	[[ $# -ge 1 ]] || return $(errorf)

	local sep=$1 && shift

	local res in
    while [[ $# -gt 0 ]]; do
		[[ $in ]] && res+=$sep || in=_
		res+=$1
		shift
    done
    echo "$res"
}

function tmp_file {
	[[ $# -le 1 ]] || return $(errorf)

	local tmpdir_arg=--tmpdir
	if [[ $# -ge 1 ]]; then
		[[ -d $1 ]] || return $(errorf "Invalid target directory: $1")
		tmpdir_arg+==$1
	fi

	TMP_FILE=$(mktemp "$tmpdir_arg" --suffix .tmp tmp_$(uuidgen)_XXXXXXXX)

	_trace && trace "Temporary file: $TMP_FILE"

	exit_hook rm -f "$TMP_FILE"
}

function tmp_dir {
	[[ $# -le 1 ]] || return $(errorf)

	local tmpdir_arg=--tmpdir
	if [[ $# -ge 1 ]]; then
		[[ -d $1 ]] || return $(errorf "Invalid target directory: $1")
		tmpdir_arg+==$1
	fi

	TMP_DIR=$(mktemp "$tmpdir_arg" --directory tmp_$(uuidgen)_XXXXXXXX)

	_trace && trace "Temporary directory: $TMP_DIR"

	exit_hook rm -rf "$TMP_DIR"
}

function require_command {
	[[ $# -eq 1 ]] || return $(errorf)

    is_command "$1" || error "Command required: $1"
}

function run {
	[[ $# -ge 1 ]] || return $(errorf)

	if [[ $# -eq 1 && $IFS && $1 == *${IFS:0:1}* && $SHELL ]]; then
		set -- "$SHELL" -c "$1"
	fi

	_trace && trace "Running: $@"

	"$@"
}

function exec_job {
	[[ $# -gt 0 ]] || return $(errorf)

	set -m

	"$@" &

	local pid=$(jobs -p % 2>/dev/null)

	[[ $pid ]] || return

	_trace && trace "Running job process: $pid"

	exit_hook kill_job $pid
}

function kill_job {
	[[ $# -le 1 ]] || return $(errorf)

    [[ $# -eq 0 ]] && set %

    local pid spec

    if valid_uint "$1"; then
    	pid=$1

    	local n pids=($(jobs -p))
    	for ((n=1; n<=${#pids[@]}; n++)); do
    		if [[ ${pids[n-1]} == $pid ]]; then
    			spec=%$n
    			break
    		fi
    	done
	else
		pid=$(jobs -p "$1" 2>/dev/null) && spec=$1
	fi

	if [[ ! $spec ]]; then
		_trace && trace "Job process not found: $1"
		return 0
	fi

	_trace && trace "Killing job process: $pid"

	kill "$spec" 2>/dev/null
	wait -f "$spec" 2>/dev/null
}

function coproc_exec {
	[[ $# -gt 1 ]] || return $(errorf)

	local name=$1 && shift

    valid_name "$name" || return $(errorf "Invalid coprocess name")

    declare -g -A _coproc

    [[ ${_coproc[$name]} ]] && return

	set -m

	coproc "$@"

	_coproc[$name]=$COPROC_PID
	_coproc[$name:0]=${COPROC[0]}
	_coproc[$name:1]=${COPROC[1]}

	_trace && trace "Running coprocess: $name ($COPROC_PID)"

	exit_hook coproc_kill $name
}

function coproc_kill {
	[[ $# -eq 1 ]] || return $(errorf)

	local name=$1

    valid_name "$name" || return $(errorf "Invalid coprocess name")

	local pid=${_coproc[$name]}	

    [[ $pid ]] || return $(errorf "Unknown coprocess")

	unset _coproc[$name] _coproc[$name:0] _coproc[$name:1]

    kill_job $pid
}

function coproc_write {
	[[ $# -gt 1 ]] || return $(errorf)

	local fd=${_coproc[$1:1]} && shift

    [[ $fd ]] || return $(errorf "Unknown coprocess")

    if [[ $# -eq 0 ]]; then
    	cat >&$fd
    	return
    fi

    while [[ $# -gt 0 ]]; do
    	echo -n "$1" >&$fd
    	shift
    done
}

function coproc_read_line {
	[[ $# -eq 1 ]] || return $(errorf)

	local fd=${_coproc[$1:0]} && shift

    [[ $fd ]] || return $(errorf "Unknown coprocess")

    IFS= read -r COPROC_DATA <&$fd || return $(errorf "Failed reading line")
}

function coproc_read_field {
	[[ $# -eq 1 ]] || return $(errorf)

	local fd=${_coproc[$1:0]} && shift

    [[ $fd ]] || return $(errorf "Unknown coprocess")

    local size end

    IFS= read -r size <&$fd || return $(errorf "Failed reading field size")

    valid_uint "$size" || return $(errorf "Invalid field size read: $size")

    IFS= read -r -d '' -n "$size" COPROC_DATA <&$fd || return $(errorf "Failed reading field value")

    IFS= read -r end <&$fd || return $(errorf "Failed reading field end")

    [[ ${#end} -eq 0 ]] || return $(errorf "Unexpected data after field value")
}

function exit_hook {
	[[ $# -ge 1 ]] || return $(errorf)

    declare -g -a _exit_hook_p _exit_hook_s _exit_hook_c

    _exit_hook_p+=($BASHPID)
    _exit_hook_s+=(${#@})
    _exit_hook_c+=("$@")

    trap _exit_hook EXIT
}

function _exit_hook {
	local len
    while [[ ${#_exit_hook_s[@]} -gt 0 ]]; do
    	[[ ${_exit_hook_p[-1]} == $BASHPID ]] || break

    	_trace && trace "Exit hook #${#_exit_hook_s[@]}"

        len=${_exit_hook_s[-1]}

        run "${_exit_hook_c[@]: -len}" || :

        _exit_hook_c=("${_exit_hook_c[@]:0:${#_exit_hook_c[@]}-len}")
        unset _exit_hook_s[-1]
        unset _exit_hook_p[-1]
    done
}

__functions__=_
