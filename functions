#!/usr/bin/env bash

[[ $__functions__ ]] && return

_error_ () { echo 0; }
_warn_  () { echo 1; }
_note_  () { echo 2; }
_msg_   () { echo 3; }
_debug_ () { echo 4; }
_trace_ () { echo 5; }

_error () { log -0; }
_warn  () { log -1; }
_note  () { log -2; }
_msg   () { log -3; }
_debug () { log -4; }
_trace () { log -5; }

error () { log 0 "$@"; exit 1; }
warn  () { log 1 "$@"; }
note  () { log 2 "$@"; }
msg   () { log 3 "$@"; }
debug () { log 4 "$@"; }
trace () { log 5 "$@"; }

function errorf {
	[[ $# -gt 0 ]] || set "Invalid arguments"

	_caller

	! ( error "$CALLER_SOURCE[$CALLER_LINENO] $CALLER_FUNCNAME:" "$@" )

	echo 2
}

function warnf {
	[[ $# -gt 0 ]] || set "Unexpected arguments"

	_caller

	warn "$CALLER_SOURCE[$CALLER_LINENO] $CALLER_FUNCNAME:" "$@"
}

function is_declared {
	[[ $# -ge 1 ]] || return $(errorf)

	if [[ $# -eq 1 ]]; then
		declare -p "$1" &>/dev/null
		return
	fi

	local attrs=$(declare -p "$1" 2>/dev/null)
	shift

	attrs=${attrs#* }
	attrs=${attrs%% *}

	[[ $attrs ]] || return 1

	attrs=${attrs##*-}

	local i t_attrs
	for t_attrs in "$@"; do
		for ((i=0; i<${#t_attrs}; i++)); do
			[[ $attrs != *${t_attrs:i:1}* ]] && continue 2
		done
		return 0
	done
	return 3
}

function is_string {
	[[ $# -eq 1 ]] || return $(errorf)

	if is_declared "$1" i a A; then
		return 3
	elif [[ $? -eq 3 ]]; then
		return 0
	fi
	return 1
}

function is_integer {
	[[ $# -eq 1 ]] || return $(errorf)

	is_declared "$1" i
}

function is_array {
	[[ $# -eq 1 ]] || return $(errorf)

	is_declared "$1" a
}

function is_hash {
	[[ $# -eq 1 ]] || return $(errorf)

	is_declared "$1" A
}

function is_function {
	[[ $# -eq 1 ]] || return $(errorf)

	declare -F "$1" >/dev/null
}

function is_pipeline {
	[[ $# -eq 1 ]] || return $(errorf)

	declare -F "$1"{,_,__} >/dev/null
}

function is_command {
	[[ $# -eq 1 ]] || return $(errorf)

	[[ $(type -P "$1") ]]
}

function is_exec {
	[[ $# -eq 1 ]] || return $(errorf)

	is_function "$1" || is_command "$1" || [[ $(type -t "$1") == builtin ]]
}

function bool {
	[[ $# -eq 1 ]] || return $(errorf)

	case $1 in
	true | TRUE | True | \
	yes | YES | Yes | \
	on | ON | On | \
	1)
	return 0
	;;
	false | FALSE | False | \
	no | NO | No | \
	off | OFF | Off | \
	0)
	return 1
	;;
	esac
	return 3
}


function color {
	[[ $# -eq 1 ]] || return $(errorf)

	colorc "$1" && echo -n "$COLORC"
}

function colorc {
	local - && set +x

	[[ $# -eq 1 ]] || return $(errorf)

	local -A cc=(
		[none]=0
		[black]=30
		[red]=31
		[green]=32
		[yellow]=33
		[blue]=34
		[magenta]=35
		[cyan]=36
		[white]=37
	)
	local -A sc=(
		[+]=1
		[-]=2
		[/]=3
		[=]=4
		[%]=7
	)

	unset COLORC

	local i code list elem name fmt num

	list=$1

	while [[ $list ]]; do
		elem=${list%%,*}
		list=${list:${#elem}}

		name=${elem%%[![:word:]]*}
		fmt=${elem:${#name}}

		if [[ $name ]]; then
			num=${cc[$name]}

			if [[ $num ]]; then
				[[ $list ]] && ((num+=10))
				[[ $code ]] && code+=\;
				code+=$num
			else
				code=
				break
			fi
		fi

		for ((i=0; i<${#fmt}; i++)); do
			num=${sc[${fmt:i:1}]}

			if [[ $num ]]; then
				code+=\;$num
			else
				code=
				break 2
			fi
		done

		list=${list#,}
	done

	[[ $code ]] || return

	COLORC=$'\e'[${code}m
}

function echoc {
	local - && set +x

	local nl
	[[ $1 == -n ]] && nl=$1 && shift

	local color base code sep=${IFS:0:1}

	if [[ $ECHOC ]]; then
		bool $ECHOC && color=_
	else
		[[ -t 1 ]] && color=_
	fi

	if [[ $ECHOC_BASE ]] && colorc "$ECHOC_BASE"; then
		base="$COLORC"
	fi

	local out space spec

	while [[ $# -gt 0 ]]; do
		spec=${1#@}

		if [[ ${1:0:1} == @ ]] && colorc "${spec%@}"; then
			code="$COLORC"
			[[ ${1: -1} == @ ]] && space=_ || space=
		else
			if [[ ! $out ]]; then
				[[ $base && $color ]] && out+=$base
			else
				[[ $space ]] && out+=$sep
			fi

			if [[ $code ]]; then
				[[ $color ]] && out+=$code
			fi

			out+=$1

			if [[ $code ]]; then
				if [[ $color ]]; then
					out+=$'\e'[0m
					[[ $base ]] && out+=$base
				fi
				code=
			fi

			space=_
		fi

		shift
	done

	[[ $base && $color ]] && out+=$'\e'[0m

	echo $nl "$out"
}

function echoe {
	echoc "$@" >&2
}

function log {
	local - && set +x

	[[ $# -ge 1 ]] || return $(errorf)

	local level=$1 && shift

	valid_int "$level" || return $(errorf "Invalid log level")

	local levels=(
		Error:red
		Warning:yellow
		Note:green
		:cyan
		DEBUG:
		TRACE:
	)

	local test drop

	if [[ $level == -* ]] ; then
		test=_
		level=${level##*-}
	fi

	local level_def=${levels[$level]} log_level=${LOG_LEVEL}

	[[ $level_def ]] || return $(errorf "Unknown log level")

	if [[ $log_level == _ ]]; then
		drop=_
	else
		valid_uint "$log_level" || log_level=3

		[[ $log_level -lt $level ]] && drop=_
	fi

	if [[ $test ]]; then
		[[ $drop ]] && return 1
		return 0
	fi
	[[ $drop ]] && return 0

	local header=${level_def%%:*} color=${level_def##*:}

	[[ $color ]] || color=none

	local header_color=$color sep_color=$color

	if [[ $color != none ]]; then
		header_color+=+=
		sep_color+=+
	fi

	local log_prefix_opt log_prefix=$LOG_PREFIX

	if [[ $log_prefix == [+-]* ]]; then
		log_prefix_opt=${log_prefix:0:1}
		log_prefix=${log_prefix#?}
	fi
	if [[ $log_prefix == _ ]]; then
		log_prefix=
	elif [[ ! $log_prefix ]]; then
		log_prefix='>>>'
	fi

	local prefix=$log_prefix prefix_args=() header_args=()

	[[ -t 2 && $log_prefix_opt != + ]] && prefix=

	if [[ $header ]]; then
		header_args+=(@$header_color "$header")
		header_args+=(@$sep_color ': ')

		if [[ $header == ${header^^} ]]; then
			[[ $log_prefix_opt != - ]] && prefix=$log_prefix
		fi
	fi

	if [[ $prefix ]]; then
		prefix_args+=("$prefix")
	fi

	if bool "$LOG_DATE" || [[ ! $LOG_DATE && $log_level -ge 4 ]]; then
		if [[ $LOG_DATE_FORMAT ]]; then
			prefix_args+=("[$(date +"$LOG_DATE_FORMAT")]")
		else
			prefix_args+=("[$(date -In)]")
		fi
	fi

	if bool "$LOG_SOURCE" || [[ ! $LOG_SOURCE && $log_level -ge 5 ]]; then
		local -i depth=0
		[[ ${BASH_SOURCE[depth]} == "${BASH_SOURCE[depth+1]}" ]] && depth+=1

		prefix_args+=("{${BASH_SOURCE[depth+1]}:${BASH_LINENO[depth]}}")
	fi

	[[ ${#prefix_args[@]} -gt 0 ]] && prefix_args=("${prefix_args[*]}${IFS:0:1}")

	echoe -n "${prefix_args[@]}" "${header_args[@]}"
	ECHOC_BASE=$color echoe "$@"
}

function ask {
	local question=$1 && shift || :

	[[ $question ]] || question=?

	local -A answers
	local answer choose reply

	for answer in "$@"; do
		[[ $answer ]] || continue

		answers[$answer]=_
	done

	[[ $# -gt 0 ]] && choose=" ($(IFS=\|; echo "$*"))"

	while :; do
		echoe -n @yellow+ "$question$choose: "
		read reply

		[[ $# -gt 0 ]] || break
		[[ $reply && ${answers[$reply]} ]] && break
	done

	echo "$reply"
}

function confirm {
	[[ $# -eq 0 ]] || return $(errorf)

	[[ $(ask "Are you sure you want to continue?" y n) == y ]]
}

function valid_name {
	[[ $# -eq 1 ]] || return $(errorf)

	[[ $1 =~ ^[[:alpha:]_][[:alnum:]_]*$ ]]
}

function valid_identifier {
	[[ $# -eq 1 ]] || return $(errorf)

	[[ $1 =~ ^[[:alpha:]]([[:alnum:]-]*[[:alnum:]])?$ ]]
}

function valid_int {
	[[ $# -eq 1 ]] || return $(errorf)

	[[ $1 =~ ^[-+]?[[:digit:]]+$ ]]
}

function valid_uint {
	[[ $# -eq 1 ]] || return $(errorf)

	valid_int "$1" && [[ ${1:0:1} != - ]]
}

function valid_float {
	[[ $# -eq 1 ]] || return $(errorf)

	[[ $1 =~ ^[-+]?[[:digit:]]*\.?[[:digit:]]+([eE][[:digit:]]+)?$ ]]
}

function valid_ufloat {
	[[ $# -eq 1 ]] || return $(errorf)

	valid_float "$1" && [[ ${1:0:1} != - ]]
}

function valid_bool {
	[[ $# -eq 1 ]] || return $(errorf)

	bool "$1" || [[ $? -ne 3 ]]
}

function parse_duration__ {
	local _x_var=$1 && _var "$1" && shift || return

	[[ $# -eq 1 ]] || return $(errorf)

	local _x_duration=$1

	local -A _x_units=(
		[s]=1
		[m]=60
		[h]=3600
	)

	local -i _x_seconds=0

	local _x_num _x_unit _x_factor

	while [[ $_x_duration ]]; do
		_x_num=${_x_duration%%[!0-9]*}

		[[ $_x_num ]] || return 1

		_x_duration=${_x_duration:${#_x_num}}
		_x_unit=${_x_duration%%[0-9]*}

		[[ $_x_unit ]] || _x_unit=s

		_x_duration=${_x_duration:${#_x_unit}}
		_x_factor=${_x_units[$_x_unit]}

		[[ $_x_factor ]] || return 1

		_x_seconds=$((_x_seconds+_x_num*_x_factor))
	done

	_set $_x_var "$_x_seconds"
}

function quote__ {
	local _x_var=$1 && _var "$1" && shift || return

	[[ $# -eq 1 ]] || return $(errorf)

	local _x_quote="'${1//\'/\'\\\'\'}'"

	_set $_x_var "$_x_quote"
}

function pad__ {
	local _x_var=$1 && _var "$1" && shift || return

	[[ $# -ge 2 && $# -le 3 ]] || return $(errorf)

	local _x_str=$1 _x_len=$2 _x_pad=$3

	[[ $_x_pad ]] || _x_pad=' '

	valid_uint "$_x_len" || return $(errorf "Invalid pad length")

	local _x_add_len _x_pad_len=${#_x_pad} _x_todo_len=$(($_x_len-${#_x_str}))

	while [[ $_x_todo_len -gt 0 ]]; do
		if [[ $_x_pad_len -lt $_x_todo_len ]]; then
			_x_add_len=$_x_pad_len
		else
			_x_add_len=$_x_todo_len
		fi

		_x_str+=${_x_pad:0:_x_todo_len}

		_x_todo_len=$((_x_todo_len-_x_add_len))
	done

	_set $_x_var "$_x_str"
}

function trim__ {
	local _x_var=$1 && _var "$1" && shift || return

	[[ $# -ge 1 && $# -le 2 ]] || return $(errorf)

	_trim $_x_var _ "$@"
}

function triml__ {
	local _x_var=$1 && _var "$1" && shift || return

	[[ $# -ge 1 && $# -le 2 ]] || return $(errorf)

	_trim $_x_var - "$@"
}

function trimr__ {
	local _x_var=$1 && _var "$1" && shift || return

	[[ $# -ge 1 && $# -le 2 ]] || return $(errorf)

	_trim $_x_var + "$@"
}

function _trim {
	local _x_var=$1 _x_side=$2 _x_str=$3 _x_chars=$4

	[[ $# -gt 3 ]] || _x_chars=$IFS

	if [[ $_x_chars ]]; then
		local _x_i _x_len

		if [[ $_x_side == - || $_x_side == _ ]]; then
			_x_len=${#_x_str}
			for ((_x_i=0; _x_i<_x_len; _x_i++)); do
				[[ $_x_chars == *"${_x_str:_x_i:1}"* ]] || break
			done
			_x_str=${_x_str:_x_i}
		fi

		if [[ $_x_side == + || $_x_side == _ ]]; then
			_x_len=${#_x_str}
			for ((_x_i=_x_len; _x_i>0; _x_i--)); do
				[[ $_x_chars == *"${_x_str:_x_i-1:1}"* ]] || break
			done
			_x_str=${_x_str:0:_x_i}
		fi
	fi

	_set $_x_var "$_x_str"
}

function list_join__ {
	local _x_var=$1 && _var "$1" && shift || return

	[[ $# -ge 1 ]] || return $(errorf)

	local _x_sep=$1 && shift

	local _x_res _x_in
	while [[ $# -gt 0 ]]; do
		[[ $_x_in ]] && _x_res+=$_x_sep || _x_in=_
		_x_res+=$1
		shift
	done

	_set $_x_var "$_x_res"
}

function list_contains {
	[[ $# -ge 1 ]] || return $(errorf)

	local elem=$1 && shift

	local e
	for e in "$@"; do
		[[ $e == "$elem" ]] && return 0
	done
	return 1
}

function list_selects {
	[[ $# -ge 1 ]] || return $(errorf)

	[[ $# -gt 1 ]] || return 0

	list_contains "$@"
}

function array_push {
	[[ $# -ge 2 && $# -le 3 ]] || return $(errorf)

	_var "$1" || return

	local _x_var=$1 _x_str=$2 _x_delim=$3

	! _debug || is_array "$_x_var" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	[[ $# -ge 3 ]] || _x_delim=,

	local _x_slen=${#_x_str} _x_dlen=${#_x_delim}
	local _x_pos=0 _x_cur= _x_res=()

	while [[ $_x_pos -lt $_x_slen ]]; do
		if [[ $_x_dlen -eq 0 ]]; then
			_x_res+=("${_x_str:_x_pos++:1}")
		elif [[ ${_x_str:_x_pos:_x_dlen} == "$_x_delim" ]]; then
			_x_res+=("$_x_cur")
			_x_cur=
			((_x_pos+=_x_dlen))
		else
			_x_cur+=${_x_str:_x_pos++:1}
		fi
	done

	[[ $_x_cur ]] && _x_res+=("$_x_cur")

	eval $_x_var+='("${_x_res[@]}")'
}

function array_split {
	[[ $# -ge 3 && $# -le 5 ]] || return $(errorf)

	_var "$1" || return

	local _x_var=$1 _x_str=$2 _x_regex=$3 _x_limit=0 _x_keep=

	! _debug || is_array "$_x_var" || [[ $? -eq 1 ]] || warnf "Variable is not an array"

	if [[ $# -ge 4 ]]; then
		_x_limit=$4

		valid_uint "$_x_limit" || return $(errorf "Invalid limit number")
	fi
	if [[ $# -ge 5 ]]; then
		if bool "$5"; then
			_x_keep=_
		elif [[ $? -ne 1 ]]; then
			return $(errorf "Invalid boolean for keep")
		fi
	fi

	local _x_count=0 _x_sep _x_rem _x_res=()

	while :; do
		((++_x_count))

		if [[ $_x_limit -eq 0 || $_x_count -lt $_x_limit ]] && [[ $_x_str =~ ($_x_regex).* ]]; then
			_x_sep=${BASH_REMATCH[1]}
			_x_rem=${BASH_REMATCH[0]}

			[[ $_x_sep ]] || _x_rem=${_x_rem:1}

			_x_res+=("${_x_str:0:-${#_x_rem}}")
			[[ $_x_keep ]] && _x_res+=("$_x_sep")

			_x_str=${_x_str:${#_x_str}-${#_x_rem}+${#_x_sep}}
		else
			[[ $? -eq 1 ]] || return $(errorf "Invalid separator regular expression")

			_x_res+=("$_x_str")
			_x_str=
		fi

		[[ $_x_str ]] || break
	done

	eval $_x_var='("${_x_res[@]}")'
}

function array_filter {
	[[ $# -ge 3 ]] || return $(errorf)

	_var "$1" || return

	local _x_var=$1 _x_op=$2 _x_type=_ _x_filter=$3 && shift 3

	! _debug || is_array "$_x_var" || warnf "Variable is not an array"

	if [[ ${#_x_op} -gt 1 ]]; then
		_x_type=${_x_op:1}
		_x_op=${_x_op:0:1}

		[[ $_x_type == [_=~@] ]] || return $(errorf "Invalid filter operator")

		if [[ $_x_type == '@' ]]; then
			! _debug || is_exec "$_x_filter" || warnf "Filter command not defined"
		else
			[[ $# -eq 0 ]] || return $(errorf)
		fi
	fi

	[[ $_x_op == [-+] ]] || return $(errorf "Invalid filter operator")

	local _x_len _x_arr=() _x_res=()

	eval _x_len=\${#$_x_var[@]}
	eval _x_arr='("${'$_x_var'[@]}")'

	local _x_val _x_match _x_found _x_arg _x_args=()

	for _x_val in "${_x_arr[@]}"; do
		_x_match=

		case $_x_type in
		'_')
			if [[ $_x_val == "$_x_filter" ]]; then
				_x_match=_
			fi
			;;
		'=')
			if [[ $_x_val == $_x_filter ]]; then
				_x_match=_
			fi
			;;
		'~')
			if [[ $_x_val =~ $_x_filter ]]; then
				_x_match=_
			else
				[[ $? -eq 1 ]] || return $(errorf "Invalid filter regular expression")
			fi
			;;
		'@')
			_x_args=()
			_x_found=

			for _x_arg in "$@"; do
				if [[ $_x_arg == *{}* ]]; then
					_x_arg=${_x_arg//\{\}/"$_x_val"}
					_x_found=_
				fi
				_x_args+=("$_x_arg")
			done
			[[ $_x_found ]] || _x_args+=("$_x_val")

			if $_x_filter "${_x_args[@]}" >/dev/null; then
				_x_match=_
			fi
			;;
		esac

		if [[ $_x_match ]]; then
			[[ $_x_op == - ]] && continue
		else
			[[ $_x_op == + ]] && continue
		fi

		_x_res+=("$_x_val")
	done

	eval $_x_var='("${_x_res[@]}")'
}

function array_map {
	[[ $# -ge 2 ]] || return $(errorf)

	_var "$1" || return

	local _x_var=$1 _x_exec=$2 && shift 2

	! _debug || is_array "$_x_var" || warnf "Variable is not an array"

	! _debug || is_exec "$_x_exec" || warnf "Map command not defined"

	local _x_len _x_arr=() _x_res=()

	eval _x_len=\${#$_x_var[@]}
	eval _x_arr='("${'$_x_var'[@]}")'

	local _x_val_ _x_found _x_pipeline _x_arg _x_args=()

	is_pipeline "$_x_exec" && _x_pipeline=_

	for _x_val_ in "${_x_arr[@]}"; do
		_x_args=()
		_x_found=

		for _x_arg in "$@"; do
			if [[ $_x_arg == *{}* ]]; then
				_x_arg=${_x_arg//\{\}/"$_x_val_"}
				_x_found=_
			fi
			_x_args+=("$_x_arg")
		done
		[[ $_x_found ]] || _x_args+=("$_x_val_")

		if [[ $_x_pipeline ]]; then
			${_x_exec}__ _x_val_ "${_x_args[@]}"
		else
			_x_val_=$($_x_exec "${_x_args[@]}") || return $?
		fi

		_x_res+=("$_x_val_")
	done

	eval $_x_var='("${_x_res[@]}")'
}

function  struct_new {
	[[ $# -gt 1 ]] || return $(errorf)

	_var "$1" || return

	local _x_var=$1 && shift

	! _debug || is_hash "$_x_var" || warnf "Struct variable is not an associative array"

	eval _x_len=\${#$_x_var[@]} && [[ $_x_len -eq 0 ]] || return $(errorf "Struct variable must be empty")

	local _x_field
	for _x_field in "$@"; do
		valid_name "$_x_field" || return $(errorf "Illegal field name")
	done

	IFS=' ' eval $_x_var[:]='"$*"'
}

function  struct_get {
	[[ $# -ge 2 && $# -le 3 ]] || return $(errorf)

	_var "$1" || return

	local _x_var=$1 _x_key=$2 _x_target=$1

	! _debug || is_hash "$_x_var" || warnf "Struct variable is not an associative array"

	[[ $_x_key ]] || return $(errorf "Illegal empty key")

	if [[ $# -ge 3 ]]; then
		_var "$3" || return

		_x_target=$3

		! _debug || is_hash "$_x_target" || warnf "Target variable is not an associative array"
	fi

	local _x_fields _x_field

	eval _x_fields=\${$_x_var[:]}

	for _x_field in $_x_fields; do
		eval $_x_target[$_x_field]=\${$_x_var[\$_x_key:$_x_field]}
	done
}

function  struct_set {
	[[ $# -ge 2 && $# -le 3 ]] || return $(errorf)

	_var "$1" || return

	local _x_var=$1 _x_key=$2 _x_target=$1

	! _debug || is_hash "$_x_var" || warnf "Struct variable is not an associative array"

	[[ $_x_key ]] || return $(errorf "Illegal empty key")

	if [[ $# -ge 3 ]]; then
		_var "$3" || return

		_x_target=$3

		! _debug || is_hash "$_x_target" || warnf "Target variable is not an associative array"
	fi

	local _x_fields _x_field

	eval _x_fields=\${$_x_var[:]}

	for _x_field in $_x_fields; do
		eval $_x_var[\$_x_key:$_x_field]=\${$_x_target[$_x_field]}
	done

	eval $_x_var[\$_x_key:]=_
}

function  struct_del {
	[[ $# -eq 2 ]] || return $(errorf)

	_var "$1" || return

	local _x_var=$1 _x_key=$2

	! _debug || is_hash "$_x_var" || warnf "Struct variable is not an associative array"

	[[ $_x_key ]] || return $(errorf "Illegal empty key")

	local _x_fkey _x_fkeys=()

	eval _x_fkeys='("${!'$_x_var'[@]}")'

	for _x_fkey in "${_x_fkeys[@]}"; do
		[[ $_x_fkey == *:* ]] || continue
		[[ ${_x_fkey%:*} == "$_x_key" ]] || continue

		eval unset $_x_var[\$_x_fkey]
	done
}

function  struct_key {
	[[ $# -eq 2 ]] || return $(errorf)

	_var "$1" || return

	local _x_var=$1 _x_key=$2 _x_found

	! _debug || is_hash "$_x_var" || warnf "Struct variable is not an associative array"

	[[ $_x_key ]] || return $(errorf "Illegal empty key")

	eval _x_found=\${$_x_var[\$_x_key:]}

	[[ $_x_found ]]
}

function  struct_keys {
	[[ $# -eq 2 ]] || return $(errorf)

	_var "$1" && _var "$2" || return

	local _x_var=$1 _x_target=$2

	! _debug || is_hash "$_x_var" || warnf "Struct variable is not an associative array"
	! _debug || is_array "$_x_target" || warnf "Target variable is not an array"

	local _x_fkey _x_fkeys=() _x_keys=()

	eval _x_fkeys='("${!'$_x_var'[@]}")'

	for _x_fkey in "${_x_fkeys[@]}"; do
		[[ $_x_fkey == *?: ]] || continue

		_x_keys+=("${_x_fkey:0:-1}")
	done

	eval $_x_target='("${_x_keys[@]}")'
}

function file_split {
	[[ $# -eq 1 ]] || return $(errorf)

	FILE_PATH=$1
	FILE_NAME=${FILE_PATH##*/}
	FILE_DIR=${FILE_PATH:0:-${#FILE_NAME}}
	while [[ ${FILE_DIR: -1} == / ]]; do
		FILE_DIR=${FILE_DIR:0:-1}
	done
	FILE_BASE=${FILE_NAME%.*}
	FILE_EXT=${FILE_NAME:${#FILE_BASE}+1}
}

function tmp_file {
	[[ $# -le 1 ]] || return $(errorf)

	local tmpdir_arg=--tmpdir
	if [[ $# -ge 1 ]]; then
		[[ -d $1 ]] || return $(errorf "Invalid target directory: $1")
		tmpdir_arg+==$1
	fi

	TMP_FILE=$(mktemp "$tmpdir_arg" --suffix .tmp tmp_$(uuidgen)_XXXXXXXX)

	_trace && trace "Temporary file: $TMP_FILE"

	exit_hook rm -f "$TMP_FILE"
}

function tmp_dir {
	[[ $# -le 1 ]] || return $(errorf)

	local tmpdir_arg=--tmpdir
	if [[ $# -ge 1 ]]; then
		[[ -d $1 ]] || return $(errorf "Invalid target directory: $1")
		tmpdir_arg+==$1
	fi

	TMP_DIR=$(mktemp "$tmpdir_arg" --directory tmp_$(uuidgen)_XXXXXXXX)

	_trace && trace "Temporary directory: $TMP_DIR"

	exit_hook rm -rf "$TMP_DIR"
}

function require_command {
	[[ $# -eq 1 ]] || return $(errorf)

	is_command "$1" || error "Command required: $1"
}

function run {
	[[ $# -ge 1 ]] || return $(errorf)

	if [[ $# -eq 1 && $IFS && $1 == *${IFS:0:1}* && $SHELL ]]; then
		set -- "$SHELL" -c "$1"
	fi

	_trace && trace "Running: $@"

	"$@"
}

function exec_job {
	[[ $# -gt 0 ]] || return $(errorf)

	set -m

	"$@" &

	local pid=$(jobs -p % 2>/dev/null)

	[[ $pid ]] || return

	_trace && trace "Running job process: $pid"

	exit_hook kill_job $pid
}

function kill_job {
	[[ $# -le 1 ]] || return $(errorf)

	[[ $# -eq 0 ]] && set %

	local pid spec

	if valid_uint "$1"; then
		pid=$1

		local n pids=($(jobs -p))
		for ((n=1; n<=${#pids[@]}; n++)); do
			if [[ ${pids[n-1]} == $pid ]]; then
				spec=%$n
				break
			fi
		done
	else
		pid=$(jobs -p "$1" 2>/dev/null) && spec=$1
	fi

	if [[ ! $spec ]]; then
		_trace && trace "Job process not found: $1"
		return 0
	fi

	_trace && trace "Killing job process: $pid"

	kill "$spec" 2>/dev/null
	wait -f "$spec" 2>/dev/null
}

function coproc_exec {
	[[ $# -gt 1 ]] || return $(errorf)

	local name=$1 && shift

	valid_name "$name" || return $(errorf "Invalid coprocess name")

	declare -g -A _coproc

	[[ ${_coproc[$name]} ]] && return

	set -m

	coproc "$@"

	_coproc[$name]=$COPROC_PID
	_coproc[$name:0]=${COPROC[0]}
	_coproc[$name:1]=${COPROC[1]}

	_trace && trace "Running coprocess: $name ($COPROC_PID)"

	exit_hook coproc_kill $name
}

function coproc_kill {
	[[ $# -eq 1 ]] || return $(errorf)

	local name=$1

	valid_name "$name" || return $(errorf "Invalid coprocess name")

	local pid=${_coproc[$name]}	

	[[ $pid ]] || return $(errorf "Unknown coprocess")

	unset _coproc[$name] _coproc[$name:0] _coproc[$name:1]

	kill_job $pid
}

function coproc_write {
	[[ $# -gt 1 ]] || return $(errorf)

	local fd=${_coproc[$1:1]} && shift

	[[ $fd ]] || return $(errorf "Unknown coprocess")

	if [[ $# -eq 0 ]]; then
		cat >&$fd
		return
	fi

	while [[ $# -gt 0 ]]; do
		echo -n "$1" >&$fd
		shift
	done
}

function coproc_read_line {
	[[ $# -eq 1 ]] || return $(errorf)

	local fd=${_coproc[$1:0]} && shift

	[[ $fd ]] || return $(errorf "Unknown coprocess")

	IFS= read -r COPROC_DATA <&$fd || return $(errorf "Failed reading line")
}

function coproc_read_field {
	[[ $# -eq 1 ]] || return $(errorf)

	local fd=${_coproc[$1:0]} && shift

	[[ $fd ]] || return $(errorf "Unknown coprocess")

	local size end

	IFS= read -r size <&$fd || return $(errorf "Failed reading field size")

	valid_uint "$size" || return $(errorf "Invalid field size read: $size")

	IFS= read -r -d '' -n "$size" COPROC_DATA <&$fd || return $(errorf "Failed reading field value")

	IFS= read -r end <&$fd || return $(errorf "Failed reading field end")

	[[ ${#end} -eq 0 ]] || return $(errorf "Unexpected data after field value")
}

function exit_hook {
	[[ $# -ge 1 ]] || return $(errorf)

	declare -g -a _exit_hook_p _exit_hook_s _exit_hook_c

	_exit_hook_p+=($BASHPID)
	_exit_hook_s+=(${#@})
	_exit_hook_c+=("$@")

	trap _exit_hook_ EXIT
}

function _exit_hook_ {
	local len
	while [[ ${#_exit_hook_s[@]} -gt 0 ]]; do
		[[ ${_exit_hook_p[-1]} == $BASHPID ]] || break

		_trace && trace "Exit hook #${#_exit_hook_s[@]}"

		len=${_exit_hook_s[-1]}

		run "${_exit_hook_c[@]: -len}" || :

		_exit_hook_c=("${_exit_hook_c[@]:0:${#_exit_hook_c[@]}-len}")
		unset _exit_hook_s[-1]
		unset _exit_hook_p[-1]
	done
}

function _caller {
	local depth=2 caller=${FUNCNAME[2]}

	[[ $caller == _* && $caller != *_ ]] && ((++depth))

	CALLER_SOURCE=${BASH_SOURCE[depth+1]}
	CALLER_LINENO=${BASH_LINENO[depth]}
	CALLER_FUNCNAME=${FUNCNAME[depth]}
}

function _set {
	_var "$1" || return

	if [[ $# -gt 1 ]]; then
		eval $1=\$2
	else
		unset $1
	fi
}

function _var {
	valid_name "$1" || return $(errorf "Illegal variable name")

	[[ $1 == _x_* && $1 != *_ ]] && return $(errorf "Conflicting variable name")

	return 0
}

__functions_init() {
	local fct name args=()

	while read -r -a args; do
		fct=${args[-1]}
		[[ $fct == *[[:alnum:]]__ ]] || continue

		name=${fct:0:-2}
		[[ $name ]] || continue

		eval '
			function '$name'_ {
				[[ $# -gt 0 ]] || return $(errorf)

				_var "$1" || return

				local _x_var=$1 _x_val

				eval _x_val=\$$_x_var

				'$fct' "$_x_var" "$_x_val" "${@:2}"
			}

			function '$name' {
				local out

				'$fct' out "$@"

				echo -n "$out"
			}
		'
	done < <(
		declare -F
	)
}

__functions_init && __functions__=_
